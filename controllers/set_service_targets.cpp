#define NODE 0
#define CORES 28
#define HALF 32
#define CONTS 32
#define FREQ_STEP_DES 8
#define MAXSTEP 23

#include <vector>
#include <sstream>
#include <fstream>
#include <iostream>
#include <unistd.h>
#include <string>
#include <cstdlib>
#include <time.h>
#include <cmath>
#include <cassert>

bool train = true;

int core_state[HALF*2];			
bool exec_slowdown[CONTS];
bool exec_okay[CONTS];
int cpus[CONTS];
int cidx = 0;
bool upscaled[CONTS];
bool have_new_sample; 	//If false, do not make new decisions based on this sample. Makes controller robust to the reporting rate.

// Setup and node state
std::string container_name_actual[CONTS];
int num_containers, num_flows, lim[CONTS];

// ContainerState should only contain the latency values.
struct containerState {
    float upscale_desired;
    float exec_desired;
    float avg_exec;
};
containerState _ctr[CONTS];

// File names for the various things needed
std::string _cname[CONTS];      // Container name
std::string _snames[CONTS];     // Stats file names
std::string _fnames[CONTS];     // Frequency file names
std::string _limFile = "workload_qos_profile";	// Change this to the file generated by set_service_targets.cpp

// Resource change
std::string stats1 = "/home/cc/paper_setup/shared/";	// Change this to the location where the containers map the reporting files.
std::string cpufreq1 = "/sys/devices/system/cpu/cpu";
std::string cpufreq2 = "/cpufreq/scaling_setspeed";
uint32_t FREQ_ARRAY[24] = {800000, 900000, 1000000, 1100000, 1200000, 1300000, 1400000, 1500000, 1600000, 1700000, 1800000, 1900000, 2000000, 2100000, 2200000, 2300000, 2400000, 2500000, 2600000, 2700000, 2800000, 2900000, 3000000, 3100000};

bool changed_core[CONTS];

// variables for cluster state
int cont_to_cluster[CONTS];         // container to cluster
int num_clusters;                   
int cluster_freqStep[CONTS];        // cluster to freqStep
/*
 * Function for profiling things to find limits and set up the targets.
 * Also print them out s.t. they can be read in easily next time.
 */

void profile_and_write() {
  float upscale, exec_metric, exec;
  int same = 0, read = 0;
  have_new_sample = true;
  int __reps = 5000;
  
  std::ofstream fpo(_limFile);
  // Check whether we are reading the same numbers as last time, and if yes, don't change anything. 
  // Read all the stats files.
  for(int i=0; i<num_containers; i++) {
    _ctr[i].exec_desired = 0;
  }

  for(int iter=0; iter<__reps; iter++) {
    for(int i=0; i<num_containers; i++) {
      std::ifstream fp(_snames[i]);
      if(fp.fail()) {
          _ctr[i].avg_exec = -1;
      } 
      else {
        std::string tmpStr;
        std::getline(fp, tmpStr);
        if(tmpStr.size() < 5) {
          continue;
        }
        read++;
        std::stringstream linestream(tmpStr);
        linestream >> exec_metric >> exec >> upscale;
        _ctr[i].exec_desired += exec;
	_ctr[i].upscale_desired += upscale;
        fp.close();
      }
    }
    usleep(10000);
  }
  for(int i=0; i<num_containers; i++) {
    _ctr[i].exec_desired = _ctr[i].exec_desired/__reps;
    _ctr[i].upscale_desired = _ctr[i].upscale_desired/__reps;
  }
  for(int i=0; i<num_containers; i++) {
    fpo << i << " " << _cname[i] << " " << _ctr[i].exec_desired << " " << _ctr[i].upscale_desired << "\n";
  }
  fpo.close();
}

/*
 * Functions for starting off with a predefined parititoning.
 */
int next = 0;
void init_cores(int idx, int cores) {
  int start = next;
  for(int i=0; i<cores; i++) {
    core_state[start] = idx; core_state[HALF+start] = idx;
    start++;
  }
  next = start;
  cpus[idx] = cores; lim[idx] = cores; changed_core[idx] = true;
}

void init_cluster() {
  next = 0;	// Reset pointer
  for(int i=0; i<CORES; i++) {
    core_state[i] = -1; core_state[i+HALF] = -1;
  }
  for(int i=CORES; i<HALF; i++) { 
    core_state[i] = -2; core_state[i+HALF] = -2;
  }
}

/* 
 * Functions for setting the allocations to the files/counters.
*/
inline std::string get_cpu_list(int i, bool isBg = false) {
    std::string str = "";
    bool first = true;
    if(isBg) {
        for(int c=0; c<HALF*2; c++) {
	  if(core_state[c] == -1) {
	    if(first) {
	      str += std::to_string(c);
              first = false;
	    } else {
              str += "," + std::to_string(c);
	    }
	  }
	}
    } else {
	int owner = i;
	//std::cout << "Inside: " << owner << " ---> " << _cname[i] << "\n";
        for(int c=0; c<HALF*2; c++) {
	  if(core_state[c] == owner) {
	    if(first) {
	      str += std::to_string(c);
              first = false;
	    } else {
              str += "," + std::to_string(c);
	    }
	  }
	}
    }
    return str;
} 

void do_all_allocations() {
    // Enforce core allocations
    // Each cluster must have at least one core to avoid pathological cond
    for(int i=0; i<num_clusters; i++) {
        if(changed_core[i] && cpus[i] > 0) {
            std::string str = ("docker update --cpuset-cpus " + get_cpu_list(i) + " ");
            for(int it=0; it<num_containers; it++) {
		if(cont_to_cluster[it] == i) {
		  if(get_cpu_list(i) == "") {
			printf("No cores allocated to cluster %d container %d\n", i, it);
			exit(-1);
		  }
		  //std::cout << str << container_name_actual[it] << "\n";
                  system((str + container_name_actual[it]).c_str());
		}
	    }
        }
    }
}


/*
 * Initialization and profile update functions
 */
void set_up_names() {
    int t_num_clusters, t_num_containers;

    std::ifstream file("/home/cc/paper_setup/config/config_cluster");	// Change to name of the config file.

    // First read the file and find the actual container names. Write them into file "container_names". Not needed if container names match what is provided in the config file.
    std::string line, line2;
    std::getline(file, line);

    t_num_containers = std::stoi(line);
    std::getline(file, line);
    t_num_clusters = std::stoi(line);
    for(int i=0; i<t_num_containers; i++) {
      std::getline(file, line);
      std::stringstream linestream(line);

      std::string data, name;
      int id, this_node;

      linestream >> id >> this_node >> name >> data;
      if(this_node != NODE)
        continue;

      std::system(("docker inspect --format '{{.Name}}' $(docker ps -q) | grep " +  name + ">> container_names").c_str());
    }
    file.close();
}

void initialize() {
    for(int i=0; i<CONTS; i++) {
        upscaled[i] = false;
	cluster_freqStep[i] = 7;
    }

    for(int i=0; i<CONTS; i++) {
        _fnames[i] = cpufreq1+std::to_string(i)+cpufreq2;
    }
    init_cluster();

    int t_num_clusters, t_num_containers;
    std::ifstream file("/home/cc/paper_setup/config/config_social_cluster");
    std::ifstream file2("container_names");
    std::string line, line2;
    std::getline(file, line);

    t_num_containers = std::stoi(line);
    std::getline(file, line);
    t_num_clusters = std::stoi(line);

    num_clusters = 0; num_containers = 0;
    // Read the input file and set up things.
    int cnt=0; float discard;
    for(int i=0; i<t_num_containers; i++) {
      std::getline(file, line);
      std::stringstream linestream(line);
        
      int id, this_node;
      std::string name;
      int clusterID; int num_cores;

      linestream >> id >> this_node >> name;
      if(this_node != NODE)
        continue;
      
      std::getline(file2, line2); 
      _cname[cnt] = name;
      container_name_actual[cnt] = line2;
      
      linestream >> _ctr[cnt].exec_desired >> discard;
      linestream >> clusterID >> num_cores;

      cont_to_cluster[cnt] = clusterID;
      _ctr[cnt].avg_exec = _ctr[cnt].exec_desired;
      _snames[cnt] = stats1+name;

      init_cores(clusterID, num_cores);
      if(clusterID > num_clusters)
        num_clusters = clusterID;
      
      num_containers++;
      cnt++;
    }
    num_clusters++;
    file.close();
    file2.close();

    do_all_allocations();
}

int main(int argc, char* argv[]) {
    set_up_names();
    initialize();
    profile_and_write();
    return 1;
}
